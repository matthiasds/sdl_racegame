/*
 * PlayerSpeedSystem.cpp
 *
 *  Created on: 15-apr.-2015
 *      Author: Matthias
 */

#include "PlayerSpeedSystem.h"
#include <cmath>
#include <iostream>
#include "GameOptions.h"

/**
 * PlayerSpeedSystem:
 * This player uses the outputs generated by the (Sdl)InputSystem to set the player speed (VelocityComponent).
 * By dividing this (Sdl)InputSystem and this speed control. The future possibility of other
 * input systems other then Sdl or other then keyboard (eg. touch) are possible.
 */


/**
 * Constructor: The Components below are the components to which this system is subscribed.
 * This System is applied to ALL entities having (minimum) ALL of the Components below.
 */
PlayerSpeedSystem::PlayerSpeedSystem() {
	addComponentType<InputComponent>();
	addComponentType<VelocityComponent>();
}


/**
 * processEntity: This function is executed for all entities (individual = one by one) that contain the Components
 * the System is subscribed to in the constructor (above).
 * If you want to make use of this System on a certain entity. The components described in the constructor should be added
 * to the Entity in the (Sdl)EntityFactory.
 * @param entity: the pointer to the current entity (an entity is used as container of all components and has a unique id)
 */
void PlayerSpeedSystem::processEntity(Entity* entity) {
	int velocityY = velocityMapper.get(entity)->getVelocityY();
	int velocityX = velocityMapper.get(entity)->getVelocityX();
	Inputs input = inputMapper.get(entity)->getInputs();
	std::bitset<BITSIZE> mySystemSpeedLock =  getSystemBit();
	VelocityComponent* thisVelocityComponent = velocityMapper.get(entity);

	if(input == UP){
		if (thisVelocityComponent->testVelocityLockAvailable(Y_PLUS_LOCK,mySystemSpeedLock)) {
			thisVelocityComponent->setVelocityLock(Y_PLUS_LOCK,mySystemSpeedLock);
			if (velocityY < MAX_PLAYER_FORWARD_SPEED) {
				velocityY++;
			}
		}
	}
	else if(input == DOWN){
		if (thisVelocityComponent->testVelocityLockAvailable(Y_MIN_LOCK,mySystemSpeedLock)) {
			thisVelocityComponent->setVelocityLock(Y_MIN_LOCK,mySystemSpeedLock);
			if (velocityY > MAX_PLAYER_REVERSE_SPEED && velocityY <= 0) {
				velocityY--;
			}
			else if (velocityY > 0)
			{
				velocityY-=3;
			}
		}
	}
	if(input == LEFT){
		if (thisVelocityComponent->testVelocityLockAvailable(X_MIN_LOCK,mySystemSpeedLock)) {
			thisVelocityComponent->setVelocityLock(X_MIN_LOCK,mySystemSpeedLock);
			velocityX--;
			//limit velocity
			int limit = - std::abs(velocityY)/2;
			velocityX = velocityX < limit ? limit : velocityX;
		}

	}
	else if(input == RIGHT){
		if (thisVelocityComponent->testVelocityLockAvailable(X_PLUS_LOCK,mySystemSpeedLock)) {
			thisVelocityComponent->setVelocityLock(X_PLUS_LOCK,mySystemSpeedLock);
			velocityX++;
			//limit velocity
			int limit = std::abs(velocityY)/2;
			velocityX = velocityX > limit ? limit : velocityX;
		}
	}
	else { //no key is pressed
		//go to 0 but not immediate but wit deceleration relative  to speed
		thisVelocityComponent->clrAllVelocityLocksOfSystem(mySystemSpeedLock); //free speed lock. Going to 0 can be overruled
		if (thisVelocityComponent->testVelocityLockAvailable()) {
			if (velocityX != 0) {
				velocityX -= velocityX/2;
			}
			if (std::abs(velocityX) <= 1) { //snap to 0
				velocityX = 0;
			}
		}
	}


	velocityMapper.get(entity)->setVelocityY(velocityY);
	velocityMapper.get(entity)->setVelocityX(velocityX);
}


/**
 * Destructor: As Systems generally do not contain data (only Components do) the Systems destructor doesn't have a function
 */
PlayerSpeedSystem::~PlayerSpeedSystem() {
}

/**
* init: not used in this System
*/
void PlayerSpeedSystem::init() {
}

